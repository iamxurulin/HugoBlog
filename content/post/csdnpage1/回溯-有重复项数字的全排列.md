---
title: "回溯-有重复项数字的全排列"
date: 2026-01-18 04:30:00
categories:
- 算法
tags:
  - 搜索
draft: false
---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0ce47ae315aa49119b16448b18bc13aa.jpeg#pic_center)
### 求解代码

```java
ArrayList<ArrayList<Integer>> ans  = new ArrayList<>();
    public ArrayList<ArrayList<Integer>> permuteUnique (int[] num) {
        ArrayList<Integer> track = new ArrayList<>();
        boolean[] used = new boolean[num.length];
        Arrays.sort(num);
        backtrack(num, track, used);
        return ans;
    }

    private void backtrack(int[] num,ArrayList<Integer> track,boolean[] used){
        if(track.size()==num.length){
            ans.add(new ArrayList<>(track));
            return;
        }

        for(int i=0;i<num.length;i++){
            if(used[i]){
                continue;
            }

            if(i>0&&num[i]==num[i-1]&&!used[i-1]){
                continue;
            }

            track.add(num[i]);
            used[i]=true;
            backtrack(num, track, used);
            track.remove(track.size()-1);
            used[i]=false;
        }
    }
```
### 小贴士

在代码层面，这道【有重复项数字的全排列问题】和【没有重复项数字的全排列问题】不同的就是增加了**一个排序语句**和**一个if语句**。

其中，排序是为了让重复元素相邻，后续只需要判断相邻的重复元素即可。

那下面的`if`语句为什么是`!used [i-1]` 才跳过呢？

这里可能有点绕，主要是因为：

如果**当前元素**和**前一个元素**重复，且**前一个元素**没被使用，那么**选当前元**素的所有递归分支，和**选前一个元素**的递归分支，是**完全一模一样**的！

直白一点就是，**前一个重复元素**都没选，你还选**当前这个**，纯属多此一举，还会制造重复，必须剪掉！

