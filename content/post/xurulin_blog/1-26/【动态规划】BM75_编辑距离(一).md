---
title: "【动态规划】BM75 编辑距离(一)"
date: 2026-01-23 19:50:03
categories:
  - 算法
tags:
  - 动态规划
draft: false
---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/94d1d7ff8ffe4320b7b14b15a3c323e4.jpeg#pic_center)
### 求解代码

```java
public int editDistance(String str1, String str2) {
        int m = str1.length();
        int n = str2.length();
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }

        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (str1.charAt(i - 1) == str2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }

            }
        }
        return dp[m][n];
    }
```

### 小贴士

1.dp[i][j]的意思是将str1的前i个字符转换为str2的前j个字符，所需要的最小编辑距离。
至于为什么要加1，是因为这里考虑了下标为0位置代表的空字符串，也就是DP的边界条件。
单独拎出来的那两个for循环，处理的是把空字符串转成str2的前j个字符需要j次**插入**操作，以及把str1的前i个字符转成空字符串需要i次**删除**操作。

2.下面的两个for循环嵌套，是把str1的前m个字符转成str2的前n个字符，这里charAt方法是i-1主要是因为第i个字符对应的下标是i-1。
