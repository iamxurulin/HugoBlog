---
title: "动态规划-正则表达式匹配"
date: 2026-01-23 23:42:18
categories:
  - 算法
tags:
  - 动态规划
draft: false
---

![](https://i-blog.csdnimg.cn/direct/9c0bb5e0e3ff498890110ed80b3d4b1d.jpeg)

![](https://i-blog.csdnimg.cn/direct/18422d56898546b0913781f09ade0918.jpeg)

### 求解代码

```java
public boolean match (String str, String pattern) {
        int m = str.length();
        int n = pattern.length();

        boolean[][] dp = new boolean[m+1][n+1];

        for(int i=0;i0&&(str.charAt(i-1)==pattern.charAt(j-1)||pattern.charAt(j-1)=='.')){
                            dp[i][j]=dp[i-1][j-1];
                        }
                    }else{
                        if(j>=2){
                            dp[i][j]|=dp[i][j-2];
                        }

                        if(i>=1&&j>=2&&(str.charAt(i-1)==pattern.charAt(j-2)||pattern.charAt(j-2)=='.')){
                            dp[i][j]|=dp[i-1][j];
                        }
                    }
                }
            }               
        }
        return dp[m][n];
    }
```

### 小贴士

`DP`这个`boolean`数组，`dp[i][j]`的意思是`str`的前`i`个字符和`pattern`的前`j`个字符，能否匹配成功。

这里的`DP`数组，考虑了下标0位置的空字符串，所以为了存储整个字符串，`DP`数组长度需要`+1`。

这里没有像编辑距离那题一样单独处理初始化逻辑，而是在嵌套`for`循环的逻辑中处理的，这样代码会更简洁一些。

这里有个细节需要注意一下就是，`dp[i][j]`是**前**`i/j`个字符，所以`pattern`的**第**`j`个字符对应原字符串的下标为`j-1`的字符，其实和【编辑距离】的下标转换是一样的。

当`pattern`非空的时候，大范围是考虑了`pattern[j-1]`是否为`*`两种情况。

1.当`pattern[j-1]`不是`*`时，如果`str`非空并且和`str[j-1]`相对或者`pattern[j-1]`直接是`.`的话，说明匹配成功。

2.当`pattern[j-1]`是`*`的话，就需要考虑是**零次匹配前面的字符**还是**匹配多次前面的字符**的问题了。

因为`pattern[j-1]`是`*`，所以`pattern[j-2]`就是`*`的前驱字符，那处理这类情况就应该着重看看`pattern[j-2]`了。

- 如果是匹配`0`次前驱字符，那`pattern`的`j-2`和`j-1`位都可以舍弃，此时要判断`str`前`i`个和`pattern`前`j`个是否匹配，等价于判断`str`前`i`个和`pattern`前`j-2`个是否匹配。

- 如果是匹配了多次前驱字符，那就让`pattern`保持不动，让`str`的前`i-1`个字符和`pattern`的前`j`个字符继续匹配。
