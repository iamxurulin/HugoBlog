---
title: "【优先级队列】主持人调度（二）"
date: 2026-01-27 23:08:23
categories:
  - 算法
tags:
  - 栈与队列
draft: false
---


![](https://i-blog.csdnimg.cn/img_convert/ad986eae5b08ba541b82a3007c168cc2.png)



### 求解代码
```java
public int minmumNumberOfHost (int n, int[][] startEnd) {
        Arrays.sort(startEnd,(a,b)->{
            if(a[0]==b[0]){
                return Integer.compare(a[1], b[1]);
            }
            return Integer.compare(a[0], b[0]);
        });

        PriorityQueue<Integer> queue = new PriorityQueue<>();
        int maxHost = 0;
        for(int[] activity:startEnd){
            while(!queue.isEmpty()&&queue.peek()<=activity[0]){
                queue.poll();
            }

            queue.offer(activity[1]);
            maxHost = Math.max(maxHost,queue.size());
        }
        return maxHost;
    }
```

### 踩坑记录
❌1.排序比较器整数溢出

```java
Arrays.sort(startEnd, (a, b) ->
    (a[0] == b[0] ? b[1] - a[1] : a[0] - b[0])
);
```

❌2.返回值不能返回最后的堆大小

```java
return queue.size(); // 
```

因为题目要的是整个过程中，堆出现过的**最大大小。**

❌3.释放主持人只用 if可能不够

```java
if (queue.peek() <= activity[0]) {
    queue.poll();
}
```

因为实际情况下可能有多个活动已经结束。


