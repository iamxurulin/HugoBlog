---
title: "二维前缀和妙用：快速检测边框正方形"
date: 2025-12-02 23:15:04
categories:
- 算法
tags:
- leetcode
draft: false
---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/03d26e9b80704d29a27bb968f7a474b3.jpeg#pic_center)
### 求解思路

这道题的核心是枚举所有可能的正方形，然后快速判断其边框是否全为1。

我们首先把原始矩阵转换成二维前缀和数组，这样就能在O(1)时间内计算任意矩形区域内1的个数。

接下来枚举每个可能的左上角点，从已知的最大边长开始向外扩展，对于每个候选正方形，我们计算整个正方形区域的1的个数，再减去内部正方形的1的个数，如果结果等于4条边上应有的格子数（即4×(边长-1)），就说明边框全是1，此时更新答案。

这种方法的巧妙之处在于利用前缀和避免了逐个检查边框元素，同时通过从已知答案开始扩展，减少了不必要的计算。

### 代码实现

```java
public static int largest1BorderedSquare(int[][] g) {
    int n = g.length;
    int m = g[0].length;
    build(n, m, g);
    
    // 特判：矩阵全是0
    if (sum(g, 0, 0, n - 1, m - 1) == 0) {
        return 0;
    }
    
    int ans = 1;
    for (int a = 0; a < n; a++) {
        for (int b = 0; b < m; b++) {
            // 枚举左上角(a,b)，从当前最大边长+1开始尝试
            for (int c = a + ans, d = b + ans, k = ans + 1; 
                 c < n && d < m; c++, d++, k++) {
                // 边框1的个数 = 整个正方形的1 - 内部正方形的1
                if (sum(g, a, b, c, d) - sum(g, a + 1, b + 1, c - 1, d - 1) 
                    == (k - 1) << 2) {
                    ans = k;
                }
            }
        }
    }
    return ans * ans;
}

// 构建二维前缀和数组
public static void build(int n, int m, int[][] g) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            g[i][j] += get(g, i, j - 1) + get(g, i - 1, j) 
                     - get(g, i - 1, j - 1);
        }
    }
}

// 查询矩形区域和
public static int sum(int[][] g, int a, int b, int c, int d) {
    return a > c ? 0 : (g[c][d] - get(g, c, b - 1) 
                       - get(g, a - 1, d) + get(g, a - 1, b - 1));
}

// 安全获取值
public static int get(int[][] g, int i, int j) {
    return (i < 0 || j < 0) ? 0 : g[i][j];
}
```

---
如果觉得有帮助，欢迎点赞、关注、转发~
