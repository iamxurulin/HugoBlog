---
title: "递归-在二叉树中找到两个节点的最近公共祖先"
date: 2026-01-14 19:01:55
categories:
- 算法
tags:
  - 二叉树
draft: false
---

![在这里插入图片描述](/images/8989da57c17e4343b33fdc89b3b199ba-a0cd98a7.jpeg)
![在这里插入图片描述](/images/84500be1dc4148128a847b564bd03c35-1e187fc9.jpeg)
### 求解代码

前文[【非递归】二叉搜索树的最近公共祖先](https://blog.csdn.net/qq_44678890/article/details/156913148?spm=1001.2014.3001.5501)我们利用**非递归+迭代的方式**求出了二叉搜索树的最近公共祖先，主要还是利用了二叉搜索树**左子树所有节点值<根节点值<右子树所有节点值**的特性。

但是，普通二叉树的节点值没有这样的规律，没办法通过数值的大小进行位置的判断力。

本文使用**递归的方式**求普通二叉树的最近公共祖先：

```java
public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        if (root == null) {
            return -1;
        }
        if (root.val == o1 || root.val == o2) {
            return root.val;
        }



        int left = lowestCommonAncestor(root.left, o1, o2);
        int right = lowestCommonAncestor(root.right, o1, o2);

        if (left == -1) {
            return right;
        }

        if (right == -1) {
            return left;
        }

        return root.val;

    }
```

