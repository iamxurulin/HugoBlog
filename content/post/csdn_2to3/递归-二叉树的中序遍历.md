---
title: "递归-二叉树的中序遍历"
date: 2026-01-11 17:46:53
categories:
- 算法
tags:
  - 二叉树
draft: false
---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/71be02f82989448c89b684a364b448d7.jpeg#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a69ed94345e942bf9f375cd97774ab07.jpeg#pic_center)

```java
public void inorder(List<Integer> list, TreeNode root){
		if(root==null){
			return;
		}

		inorder(list, root.left);
		list.add(root.val);
		inorder(list, root.right);
	}
    public int[] inorderTraversal (TreeNode root) {
        
		List<Integer> list = new ArrayList<>();
		inorder(list, root);

		int[] ans = new int[list.size()];

		for(int i=0;i<list.size();i++){
			ans[i]=list.get(i);
		}

		return ans;
    }
```
**说明**：

和前文[【递归】二叉树的前序遍历](https://blog.csdn.net/qq_44678890/article/details/156832278?spm=1001.2014.3001.5501)的区别就是把`list.add(root.val);` 这行代码放到了两个递归之间。

**二叉树递归遍历的灵魂**就在于`list.add(root.val);` 的位置决定遍历的方式，而递归的逻辑完全不变。
