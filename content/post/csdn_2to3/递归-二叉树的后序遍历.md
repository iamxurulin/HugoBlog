---
title: "递归-二叉树的后序遍历"
date: 2026-01-11 17:57:22
categories:
- 算法
tags:
  - 二叉树
draft: false
---

![在这里插入图片描述](/images/752fb88b2ccb44d4882fa88c6deb39bd-2e6149a0.jpeg)
### 求解代码

```java
public void postorder(List<Integer> list, TreeNode root){
		if(root==null){
			return;
		}

		postorder(list, root.left);
		postorder(list, root.right);
		
		list.add(root.val);
	}
    public int[] postorderTraversal (TreeNode root) {
        
		List<Integer> list = new ArrayList<>();
		postorder(list, root);

		int[] ans = new int[list.size()];

		for(int i=0;i<list.size();i++){
			ans[i]=list.get(i);
		}

		return ans;
    }
```

**说明：**

和前文[【递归】二叉树的前序遍历](https://blog.csdn.net/qq_44678890/article/details/156832278?spm=1001.2014.3001.5501)的区别就是把`list.add(root.val); `这行代码放到了两个递归之**后**。

总结一下：

 - 前序遍历，`list.add(root.val); `这行代码放到两个递归之**前**。
 - 中序遍历，`list.add(root.val); `这行代码放到两个递归之**间**。
 - 后序遍历，`list.add(root.val); `这行代码放到两个递归之**后**。

二叉树递归遍历的**灵魂**就在于`list.add(root.val); `的位置决定遍历的方式，而递归的逻辑完全不变。
