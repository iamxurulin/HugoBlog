---
title: "前序+中序-重建二叉树"
date: 2026-01-14 22:48:04
categories:
- 算法
tags:
  - 二叉树
draft: false
---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/45bcf785a43445559cf041a1551929e8.jpeg#pic_center)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ac3a341c907949c9a24b412c02cb627a.jpeg#pic_center)
### 求解代码

```java
public TreeNode reConstructBinaryTree (int[] preOrder, int[] vinOrder) {
        int pre_len = preOrder.length;
        int vin_len = vinOrder.length;

        if (pre_len == 0 || vin_len == 0) {
            return null;
        }

        TreeNode root = new TreeNode(preOrder[0]);
        for (int i = 0; i < vinOrder.length; i++) {
            if (preOrder[0] == vinOrder[i]) {
                // 左子树：前序从[1, i+1)  中序从[0, i)
                root.left = reConstructBinaryTree(Arrays.copyOfRange(preOrder, 1, i + 1),
                                                  Arrays.copyOfRange(vinOrder, 0, i));
                // 右子树：前序从[i+1, pre_len)  中序从[i+1, vin_len)
                root.right = reConstructBinaryTree(Arrays.copyOfRange(preOrder, i + 1,
                                                   preOrder.length), Arrays.copyOfRange(vinOrder, i + 1, vinOrder.length));
                break;
            }

        }
        return root;
    }
```
### 小贴士

```bash
Arrays.copyOfRange(原数组, from, to) → 复制数组的[from, to)区间，返回新数组；
```

**中序遍历**分割数组比较好理解：

中序遍历过程中左子树是从`[0,i)`，右子树是从`[i+1,vin_len)`

**前序遍历**分割数组可能会有点绕，这里解释一下：

当**中序遍历**到位置`i`时，可以得知左子树所在的区间是`[0,i-1]`，长度就是`i`；

那么回到前序遍历中来，因为同一棵树它的左子树的长度在前序遍历和中序遍历的过程中是相同的，也就是长度是`i`，那么又因为前序遍历的`0`位置是根节点，则前序遍历的左子树所在的区间就是`[1,i]`。

由于`Arrays.copyOfRange`方法是左闭右开区间，所以前序遍历过程中，左子树是从`[1,i+1)`，右子树就是从`[i+1,pre_len)`。

