---
title: "归并-单链表的排序"
date: 2026-01-08 23:31:15
categories:
- 算法
tags:
  - 链表
draft: false
---

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0a366e5bba2949a6b63727a8c959add4.jpeg#pic_center)
### 求解代码

```java
ListNode merge(ListNode pHead1, ListNode pHead2) {
    // 任一链表为空，直接返回另一链表
    if(pHead1==null){
        return pHead2;
    }
    if(pHead2==null){
        return pHead1;
    }

    // 虚拟节点：简化合并后链表头节点的处理
    ListNode dummy = new ListNode(0);
    ListNode head = dummy; // 结果链表的当前指针，用于挂载节点

    while(pHead1!=null&&pHead2!=null){
        if(pHead1.val<=pHead2.val){
            head.next = pHead1;
            pHead1=pHead1.next; 
        }else{
            head.next = pHead2;
            pHead2 = pHead2.next; 
        }
        head=head.next; // 结果指针后移
    }

    // 拼接剩余节点
    if(pHead1!=null){
        head.next = pHead1;
    }else{        
        head.next = pHead2;
    }

    // 返回合并后的链表
    return dummy.next;
}

public ListNode sortInList (ListNode head) {
    // 空链表/单节点链表，直接返回
    if(head ==null||head.next==null){
        return head;
    }

    ListNode left = head;        // 慢指针前驱（用于断开链表）
    ListNode mid = head.next;    // 慢指针（最终指向中点）
    ListNode right = head.next.next; // 快指针（步长2）

    // 持续移动指针，直到快指针到末尾
    while(right!=null&&right.next!=null){
        left = left.next;        // 慢指针前驱后移
        mid = mid.next;          // 慢指针后移（步长1）
        right = right.next.next; // 快指针后移（步长2）
    }
    left.next = null; // 断开链表，拆分为「head→left」和「mid→末尾」两段

    // 递归排序两段链表，再合并结果
    return merge(sortInList(head), sortInList(mid));
}
```

